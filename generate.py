"""
Use trained weights to compose
"""

import pickle
import numpy as np
import tensorflow as tf

from utils import *
from network import *

# Use the best weights to generate notes
def generate():
    # Load traing data (data/notes)
    with open('data/notes', 'rb') as filepath:
        notes = pickle.load(filepath)

    # Get all names of pitchs
    pitch_names = sorted(set(item for item in notes))

    # Get all differnt pitchs
    num_pitch = len(set(notes))

    network_input, normalized_input = prepare_sequences(notes, pitch_names, num_pitch)

    # Load the best weights, the least loss and Generate NN model
    model = network_model(normalized_input, num_pitch, "best.weights.hdf5")

    # Use NN to generate data
    prediction = generate_notes(model, network_input, pitch_names, num_pitch)

    # Use predicted musical data to create MIDI then to MP3
    create_music(prediction)


def prepare_sequences(notes, pitch_names, num_pitch):
	"""
	Prepare sequences needed in training
	"""
	sequence_length = 80	# the length of a training sequence
	
	# Dictory: note -> integer
	pitch_to_int = dict((pitch, num) for num, pitch in enumerate(pitch_names))
	
	# Create input and output sequences
	network_input = []
	network_output = []
	
	for i in range(0, len(notes) - sequence_length, 1):
		sequence_in = notes[i : i+sequence_length]
		sequence_out = notes[i+sequence_length]
		
		network_input.append([pitch_to_int[char] for char in sequence_in])
		network_output.append([pitch_to_int[sequence_out]])
	
	n_patterns = len(network_input)
	
	# Convert input sequences to the shape of LSTM input
	normalized_input = np.reshape(network_input, (n_patterns, sequence_length, 1))
	
	# Normalize the input
	normalized_input = normalized_input / float(num_pitch)
	
	return (network_input, normalized_input)
	

def generate_notes(model, network_input, pitch_names, num_pitch):
	"""
	Based on a sequence of notes, use NN to genertae new notes
	"""
	
	# Select a sequence from input randomly, as the beginning
	start = np.random.randint(0, len(network_input) - 1)
	
	# Dict: int -> pitch
	int_to_pitch = dict((num, pitch) for num, pitch in enumerate(pitch_names))
	
	pattern = network_input[start]
	
	# Pitchs generated by LSTM
	prediction_output = []
	
	# Generate 700 notes
	for note_index in range(700):
		prediction_input = np.reshape(pattern, (1,len(pattern),1))
		
		# normalize
		prediction_input = prediction_input / float(num_pitch)
		
		# Use LSTM with the best weights to generate / predict new notes
		prediction = model.predict(prediction_input, verbose = 0)
		
		# max, note
		index = np.argmax(prediction)
		
		# int -> pitch
		result = int_to_pitch[index]
		
		prediction_output.append(result)
		
		# forward
		pattern.append(index)
		pattern = pattern[1 : len(pattern)]
	return prediction_output

if __name__ == '__main__':
    generate()
